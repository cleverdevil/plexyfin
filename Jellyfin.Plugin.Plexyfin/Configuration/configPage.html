<!DOCTYPE html>
<html>
<head>
    <title>Plexyfin</title>
    <style>
        /* Base plugin styles */
    </style>
    <script type="text/javascript">
        // No complex notification overlay, we'll use simple status messages instead
    </script>
</head>
<body>
    <div id="Plexyfin" data-role="page" class="page type-interior pluginConfigurationPage">
        <div data-role="content">
            <div class="content-primary">
                <div class="verticalSection">
                    <div class="sectionTitleContainer">
                        <h2 class="sectionTitle">Plex Server Configuration</h2>
                    </div>
                    <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                        Configure the connection to your Plex Media Server. This is required for syncing collections and other data.
                    </div>
                </div>

                <form class="plexyfinconfigurationForm">
                    <div class="inputContainer">
                        <label for="PlexServerUrl">Plex Server URL:</label>
                        <input id="PlexServerUrl" name="PlexServerUrl" type="text"
                               placeholder="http://plexserver:32400" required />
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Enter the URL to your Plex Media Server, including port number (e.g., http://192.168.1.100:32400)
                        </div>
                    </div>

                    <div class="inputContainer">
                        <label for="PlexApiToken">Plex API Token:</label>
                        <input id="PlexApiToken" name="PlexApiToken" type="password" required />
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Enter your Plex API Token. You can find this by following the instructions
                            <a href="https://support.plex.tv/articles/204059436-finding-an-authentication-token-x-plex-token/"
                              target="_blank">here</a>.
                        </div>
                    </div>

                    <div>
                        <button is="emby-button" type="button" class="raised" id="btnTestConnection">
                            <span>Test Connection</span>
                        </button>
                        <div class="fieldDescription" id="connectionStatus" style="margin-top: 10px;"></div>
                    </div>

                    <div class="verticalSection" id="plexLibrariesSection" style="display: none;">
                        <h3 class="sectionTitle">Plex Libraries</h3>
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Select which Plex libraries to include when syncing collections and playlists.
                            Only selected libraries will be synchronized. By default, all libraries are selected.
                        </div>

                        <div id="libraryList" style="margin-top: 10px;">
                            <!-- Libraries will be populated here dynamically -->
                        </div>

                        <div class="buttonContainer" style="margin-top: 15px;">
                            <button is="emby-button" type="button" class="raised" id="btnSelectAllLibraries">
                                <span>Select All</span>
                            </button>
                            <button is="emby-button" type="button" class="raised" id="btnUnselectAllLibraries" style="margin-left: 10px;">
                                <span>Unselect All</span>
                            </button>
                        </div>
                    </div>

                    <div class="verticalSection">
                        <h3 class="sectionTitle">Sync Options</h3>

                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="SyncCollections" />
                                <span>Sync Collections from Plex</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, collections from Plex will be synced to Jellyfin.
                        </div>

                        <!-- Playlist sync feature removed -->

                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            <strong>Collection Syncing:</strong> Collections from Plex are now synced more intelligently.
                            When a collection in Plex matches a collection in Jellyfin by name, the Jellyfin collection
                            will be deleted and recreated with the exact information from Plex (including membership,
                            sort title, description, and artwork). This ensures collections are always precisely in sync
                            with Plex.
                        </div>

                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="SyncArtwork" />
                                <span>Sync Collection Artwork</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, collection posters and backdrops will be synced from Plex to Jellyfin.
                        </div>

                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="SyncItemArtwork" />
                                <span>Sync Movie and TV Show Artwork</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, poster images and backdrops for individual movies and TV shows will be synced from Plex to Jellyfin.
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px; color: #d9534f; font-weight: bold; border: 1px solid #d9534f; padding: 10px; border-radius: 4px;">
                            <span style="font-size: 16px;">⚠️ WARNING</span><br>
                            Enabling artwork sync will <strong>REPLACE ALL EXISTING ARTWORK</strong> in Jellyfin with the artwork from Plex. All existing posters and backdrops in Jellyfin will be deleted and replaced with Plex's artwork. This operation cannot be undone.<br><br>
                            <strong>It is STRONGLY recommended to create a backup of your Jellyfin metadata directory before performing a sync.</strong>
                        </div>

                    </div>

                    <div class="verticalSection">
                        <h3 class="sectionTitle">Scheduled Sync</h3>
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="EnableScheduledSync" />
                                <span>Enable Scheduled Sync</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, collections and playlists will be automatically synced on the schedule below.
                        </div>

                        <div class="inputContainer">
                            <label for="SyncIntervalHours">Sync Interval (Hours):</label>
                            <input id="SyncIntervalHours" name="SyncIntervalHours" type="number" min="1" max="168" step="1" />
                            <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                                How often to sync from Plex (in hours). Minimum 1 hour, maximum 168 hours (1 week).
                            </div>
                        </div>
                        
                        <div class="fieldDescription" style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-left: 4px solid #0078d4; border-radius: 4px;">
                            <strong>Note:</strong> After changing scheduled sync settings, you must restart Jellyfin for the changes to take effect. Alternatively, you can manually run the sync task from Jellyfin's Scheduled Tasks page.
                        </div>
                    </div>

                    <div class="verticalSection">
                        <h3 class="sectionTitle">Advanced Options</h3>

                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="EnableDebugMode" />
                                <span>Enable Debug Mode</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, debug copies of images will be saved and more verbose logging will occur.
                            This can help with troubleshooting but uses more disk space.
                        </div>

                        <!-- MaxUrlPatternAttempts setting removed as it's no longer needed -->
                        
                        <div class="inputContainer">
                            <label for="JellyfinBaseUrl">Jellyfin Base URL:</label>
                            <input id="JellyfinBaseUrl" name="JellyfinBaseUrl" type="text"
                                   placeholder="http://localhost:8096" />
                            <div class="fieldDescription" style="font-size: 90%; margin-bottom:.15px;">
                                The base URL used for API operations (including collection deletion).
                                Only change this if your Jellyfin server is accessed through a custom URL.
                                For example: http://jellyfin:8096 or https://jellyfin.example.com
                            </div>
                        </div>
                    </div>

                    <div class="verticalSection">
                        <h3 class="sectionTitle">Save & Sync</h3>
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Save your configuration and start a manual sync from Plex to Jellyfin.
                        </div>

                        <div class="buttonContainer">
                            <button is="emby-button" type="button" class="raised button-submit" id="btnSaveConfig">
                                <span>Save Settings</span>
                            </button>

                            <button is="emby-button" type="button" class="raised" id="btnSyncNow" style="margin-left: 10px;">
                                <span>Sync Now</span>
                            </button>

                            <button is="emby-button" type="button" class="raised" id="btnDryRun" style="margin-left: 10px;">
                                <span>Dry Run (Preview Changes)</span>
                            </button>
                        </div>

                        <div class="fieldDescription" style="margin-top: 10px;">
                            "Sync Now" will immediately sync collections and artwork based on your settings.<br>
                            "Dry Run" will show what changes would be made without actually applying them.
                        </div>

                        <div class="fieldDescription" style="margin-top: 15px; color: #d9534f; font-weight: bold; border: 1px solid #d9534f; padding: 10px; border-radius: 4px;">
                            <span style="font-size: 16px;">⚠️ IMPORTANT - READ BEFORE SYNCING</span><br>
                            <ul style="padding-left: 20px; margin-top: 10px;">
                                <li>This plugin <strong>DELETES AND REPLACES</strong> artwork in Jellyfin with artwork from Plex.</li>
                                <li>All poster images and backdrop images selected for sync will be completely removed and replaced.</li>
                                <li>Custom artwork you've manually set in Jellyfin will be permanently lost.</li>
                                <li><strong>BACKUP YOUR JELLYFIN DATA</strong> before running a sync, especially the first time.</li>
                            </ul>
                        </div>

                        <!-- Progress tracking UI placeholder - actual element will be moved to document body -->
                        <div class="padded-top" style="margin-top: 2em;">
                            <div class="alert" id="syncStatus" style="font-weight: 500;"></div>
                            <div id="syncProgressMessage" style="margin-top: 1em;"></div>
                        </div>

                        <div class="padded-top" style="margin-top: 1em;">
                            <div class="alert" id="saveResult"></div>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <script type="text/javascript">
            var PlexyfinConfig = {
                pluginUniqueId: 'b9f0c474-e9a8-4292-ae41-eb3c1542f4cd',
                selectedLibraryIds: [], // Will store the selected library IDs
                activeSyncId: null,    // ID of the current sync operation
                syncPollInterval: null // Interval for polling sync status
            };

            document.querySelector('.plexyfinconfigurationForm')
                .addEventListener('submit', function(e) {
                    e.preventDefault();
                    return false;
                });

            document.querySelector('#btnSaveConfig')
                .addEventListener('click', function() {
                    saveConfiguration();
                });

            document.querySelector('#btnSyncNow')
                .addEventListener('click', function() {
                    startSync(false);
                });

            document.querySelector('#btnDryRun')
                .addEventListener('click', function() {
                    startSync(true);
                });

            document.querySelector('#btnTestConnection')
                .addEventListener('click', function() {
                    testPlexConnection();
                });

            document.querySelector('#btnSelectAllLibraries')
                .addEventListener('click', function() {
                    selectAllLibraries(true);
                });

            document.querySelector('#btnUnselectAllLibraries')
                .addEventListener('click', function() {
                    selectAllLibraries(false);
                });



            function showMessage(message, isError) {
                const saveResultElem = document.querySelector('#saveResult');
                saveResultElem.innerText = message;
                if (isError) {
                    saveResultElem.classList.add('errorMessage');
                    saveResultElem.classList.remove('successMessage');
                } else {
                    saveResultElem.classList.add('successMessage');
                    saveResultElem.classList.remove('errorMessage');
                }
                // Auto-hide after 5 seconds (or 10 seconds for longer messages)
                const hideDelay = message.length > 50 ? 10000 : 5000;
                setTimeout(() => {
                    saveResultElem.innerText = '';
                    saveResultElem.classList.remove('successMessage', 'errorMessage');
                }, hideDelay);
            }

            function showConnectionMessage(message, isError) {
                const connectionStatusElem = document.querySelector('#connectionStatus');
                connectionStatusElem.innerText = message;
                connectionStatusElem.style.color = isError ? 'red' : 'green';
            }

            function testPlexConnection() {
                Dashboard.showLoadingMsg();

                const url = document.querySelector('#PlexServerUrl').value;
                const token = document.querySelector('#PlexApiToken').value;

                if (!url || !token) {
                    showConnectionMessage("Plex server URL and API token are required", true);
                    Dashboard.hideLoadingMsg();
                    return;
                }

                ApiClient.ajax({
                    type: 'GET',
                    url: ApiClient.getUrl('/Plexyfin/test-connection') +
                         '?url=' + encodeURIComponent(url) +
                         '&token=' + encodeURIComponent(token),
                    dataType: 'json'
                }).then(function(result) {
                    Dashboard.hideLoadingMsg();

                    if (!result.success) {
                        showConnectionMessage(result.error || "Cannot connect to Plex. Check your URL and API Token.", true);
                        document.querySelector('#plexLibrariesSection').style.display = 'none';
                        return;
                    }

                    // Display the raw libraries data to debug
                    console.log("Libraries data:", JSON.stringify(result.libraries));

                    // Show the libraries section
                    document.querySelector('#plexLibrariesSection').style.display = 'block';

                    showConnectionMessage(result.message || "Successfully connected to Plex Media Server", false);

                    // Populate the libraries
                    populateLibraries(result.libraries);

                }, function(error) {
                    Dashboard.hideLoadingMsg();
                    showConnectionMessage('Error connecting to Plex: ' + error.status + ' ' + error.statusText, true);
                    document.querySelector('#plexLibrariesSection').style.display = 'none';
                });
            }

            function populateLibraries(libraries) {
                const libraryListElement = document.querySelector('#libraryList');
                libraryListElement.innerHTML = '';

                if (!libraries || libraries.length === 0) {
                    libraryListElement.innerHTML = '<div>No libraries found in your Plex server.</div>';
                    return;
                }

                // Debug the raw libraries data
                console.log("Raw libraries array:", libraries);

                // Debug each library object in detail
                libraries.forEach(function(lib, index) {
                    console.log(`Library ${index} raw:`, lib);
                    console.log(`Library ${index} JSON:`, JSON.stringify(lib));

                    // Log the property names directly
                    const propNames = Object.keys(lib);
                    console.log(`Library ${index} property names:`, propNames);
                });

                // Update the global selected libraries
                PlexyfinConfig.selectedLibraryIds = libraries
                    .filter(lib => lib.isSelected === true || lib.IsSelected === true)
                    .map(lib => lib.id || lib.Id || "");

                // Create a checkbox for each library
                libraries.forEach(function(library, index) {
                    // Create a div to hold this library entry
                    const libraryItem = document.createElement('div');
                    libraryItem.className = 'checkboxContainer';
                    libraryItem.style.marginBottom = '5px';

                    // Debug this specific library
                    console.log(`Building UI for library ${index}:`, library);

                    // Get properties with proper casing (handle both cases since JSON serialization can vary)
                    const libraryId = library.id || library.Id || '';
                    const libraryTitle = library.title || library.Title || '';
                    const libraryType = library.type || library.Type || '';
                    const isSelected = library.isSelected === true || library.IsSelected === true;

                    console.log(`Library ${index} parsed values:`, {
                        id: libraryId,
                        title: libraryTitle,
                        type: libraryType,
                        isSelected: isSelected
                    });

                    // Format the library type for display (capitalize first letter)
                    let displayType = '';
                    if (libraryType) {
                        displayType = ' (' + libraryType.charAt(0).toUpperCase() + libraryType.slice(1) + ')';
                    }

                    // Create the elements manually instead of using template literals
                    const label = document.createElement('label');
                    label.title = "Debug: id=" + libraryId + ", title=" + libraryTitle + ", type=" + libraryType;

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'libraryCheckbox';
                    checkbox.dataset.libraryId = libraryId;
                    checkbox.checked = isSelected;

                    const span = document.createElement('span');
                    span.textContent = (libraryTitle || 'Unnamed Library') + displayType;

                    // Append the elements
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    libraryItem.appendChild(label);

                    libraryListElement.appendChild(libraryItem);
                });

                // Add event listeners to all checkboxes
                document.querySelectorAll('.libraryCheckbox').forEach(function(checkbox) {
                    checkbox.addEventListener('change', function(e) {
                        const libraryId = e.target.dataset.libraryId;

                        if (e.target.checked) {
                            // Add to selected libraries if not already there
                            if (!PlexyfinConfig.selectedLibraryIds.includes(libraryId)) {
                                PlexyfinConfig.selectedLibraryIds.push(libraryId);
                                console.log('Added library: ' + libraryId);
                            }
                        } else {
                            // Remove from selected libraries
                            const index = PlexyfinConfig.selectedLibraryIds.indexOf(libraryId);
                            if (index !== -1) {
                                PlexyfinConfig.selectedLibraryIds.splice(index, 1);
                                console.log('Removed library: ' + libraryId);
                            }
                        }

                        // Update server with new selection
                        updateSelectedLibraries();
                    });
                });
            }

            function selectAllLibraries(selectAll) {
                const checkboxes = document.querySelectorAll('.libraryCheckbox');

                // Clear the selection array if deselecting all
                if (!selectAll) {
                    PlexyfinConfig.selectedLibraryIds = [];
                }

                checkboxes.forEach(function(checkbox) {
                    checkbox.checked = selectAll;

                    const libraryId = checkbox.dataset.libraryId;

                    if (selectAll) {
                        // Add to selected libraries if not already there
                        if (!PlexyfinConfig.selectedLibraryIds.includes(libraryId)) {
                            PlexyfinConfig.selectedLibraryIds.push(libraryId);
                        }
                    }
                });

                // Log the current selection
                console.log('Selected libraries (' + (selectAll ? 'all' : 'none') + '): ',
                    PlexyfinConfig.selectedLibraryIds);

                // Update server with new selection
                updateSelectedLibraries();
            }

            function updateSelectedLibraries() {
                console.log('Sending selection to server: ', PlexyfinConfig.selectedLibraryIds);

                ApiClient.ajax({
                    type: 'POST',
                    url: ApiClient.getUrl('/Plexyfin/UpdateSelectedLibraries'),
                    data: JSON.stringify(PlexyfinConfig.selectedLibraryIds),
                    contentType: 'application/json'
                }).then(function(result) {
                    // Success
                    console.log('Successfully updated selected libraries');
                    showConnectionMessage('Library selection updated successfully', false);

                    // Hide message after 3 seconds
                    setTimeout(function() {
                        document.querySelector('#connectionStatus').innerHTML = '';
                    }, 3000);
                }, function(error) {
                    console.error('Error updating libraries: ', error);
                    showMessage('Error updating selected libraries: ' + error.status + ' ' + error.statusText, true);
                });
            }

            function startSync(isDryRun) {
                try {
                    console.log('Starting sync process...');

                    // Clear any existing sync state
                    if (PlexyfinConfig.syncPollInterval) {
                        clearInterval(PlexyfinConfig.syncPollInterval);
                    }
                    PlexyfinConfig.activeSyncId = null;

                    // Clear result message
                    var resultElement = document.getElementById('saveResult');
                    if (resultElement) {
                        resultElement.innerText = '';
                    }

                    // Update the sync status message
                    var syncStatus = document.getElementById('syncStatus');
                    var syncProgressMessage = document.getElementById('syncProgressMessage');

                    if (syncStatus) {
                        syncStatus.innerText = isDryRun ? 'Dry Run in Progress...' : 'Sync in Progress...';
                        syncStatus.className = 'alert successMessage';
                    }

                    if (syncProgressMessage) {
                        syncProgressMessage.innerText = isDryRun ?
                            'Analyzing what changes would be made without applying them...' :
                            'Starting synchronization process. This may take a few moments...';
                    }

                    // Disable buttons
                    var syncButton = document.getElementById('btnSyncNow');
                    var dryRunButton = document.getElementById('btnDryRun');

                    if (syncButton) syncButton.disabled = true;
                    if (dryRunButton) dryRunButton.disabled = true;
                } catch (e) {
                    console.error('Error in startSync:', e);
                    showMessage('Error initializing sync UI. Trying to continue...', true);
                }

                // Start the sync operation
                ApiClient.ajax({
                    type: 'POST',
                    url: ApiClient.getUrl('/Plexyfin/' + (isDryRun ? 'DryRunSync' : 'sync')),
                    dataType: 'json'
                }).then(function(result) {
                    if (!result.success) {
                        showMessage(result.error || 'Failed to start sync operation', true);

                        var overlay = document.getElementById('plexyfin-notification-overlay');
                        if (overlay) overlay.style.display = 'none';

                        var syncButton = document.getElementById('btnSyncNow');
                        var dryRunButton = document.getElementById('btnDryRun');

                        if (syncButton) syncButton.disabled = false;
                        if (dryRunButton) dryRunButton.disabled = false;
                        return;
                    }

                    console.log('Sync operation started with ID:', result.syncId);
                    PlexyfinConfig.activeSyncId = result.syncId;

                    // Start polling for status
                    PlexyfinConfig.syncPollInterval = setInterval(function() {
                        pollSyncStatus(isDryRun);
                    }, 1000); // Poll every second

                }, function(error) {
                    showMessage('Error starting ' + (isDryRun ? 'dry run' : 'sync') + ': ' + (error.status ? error.status + ' ' + error.statusText : 'Unknown error'), true);

                    var overlay = document.getElementById('plexyfin-notification-overlay');
                    if (overlay) overlay.style.display = 'none';

                    var syncButton = document.getElementById('btnSyncNow');
                    var dryRunButton = document.getElementById('btnDryRun');

                    if (syncButton) syncButton.disabled = false;
                    if (dryRunButton) dryRunButton.disabled = false;
                });
            }

            function pollSyncStatus(isDryRun) {
                // Check if we have an active sync ID
                if (!PlexyfinConfig.activeSyncId) {
                    console.log('No active sync ID, cancelling poll');
                    if (PlexyfinConfig.syncPollInterval) {
                        clearInterval(PlexyfinConfig.syncPollInterval);
                        PlexyfinConfig.syncPollInterval = null;
                    }
                    return;
                }

                console.log('Polling sync status for ID: ' + PlexyfinConfig.activeSyncId);

                ApiClient.ajax({
                    type: 'GET',
                    url: ApiClient.getUrl('/Plexyfin/sync-status/' + PlexyfinConfig.activeSyncId),
                    dataType: 'json'
                }).then(function(status) {
                    // If there's no success flag or it's false
                    if (!status || !status.success) {
                        console.log('Received error response from sync status API:', status);

                        // If we've had too many errors, stop polling
                        PlexyfinConfig.errorCount = (PlexyfinConfig.errorCount || 0) + 1;

                        if (PlexyfinConfig.errorCount > 3) {
                            console.log('Too many polling errors, stopping polling');

                            if (PlexyfinConfig.syncPollInterval) {
                                clearInterval(PlexyfinConfig.syncPollInterval);
                                PlexyfinConfig.syncPollInterval = null;
                            }

                            var syncStatus = document.getElementById('syncStatus');
                            var syncProgressMessage = document.getElementById('syncProgressMessage');

                            if (syncStatus) {
                                syncStatus.innerText = 'Sync Error';
                                syncStatus.className = 'alert errorMessage';
                            }

                            if (syncProgressMessage) {
                                syncProgressMessage.innerText = status && status.message ?
                                    status.message : 'Unable to get sync status. The operation may have failed.';
                            }

                            resetUIAfterSync();
                            return;
                        }

                        // For intermittent errors, just log and continue polling
                        console.log('Continuing to poll despite error (attempt ' + PlexyfinConfig.errorCount + ')');
                        return;
                    }

                    // Reset error count on successful response
                    PlexyfinConfig.errorCount = 0;

                    // Update progress message
                    updateSyncProgressUI(status, isDryRun);

                    // Check if sync is complete
                    if (status.isComplete) {
                        console.log('Sync complete, stopping polling');

                        if (PlexyfinConfig.syncPollInterval) {
                            clearInterval(PlexyfinConfig.syncPollInterval);
                            PlexyfinConfig.syncPollInterval = null;
                        }

                        // Re-enable buttons
                        resetUIAfterSync();

                        // Show completion message
                        showCompletionMessage(status, isDryRun);
                    }
                }).catch(function(error) {
                    console.error('Error polling sync status:', error);

                    // Add error count for consecutive errors
                    PlexyfinConfig.errorCount = (PlexyfinConfig.errorCount || 0) + 1;

                    // Stop polling if we have too many consecutive errors
                    if (PlexyfinConfig.errorCount > 3) {
                        console.log('Too many polling errors, stopping polling');
                        if (PlexyfinConfig.syncPollInterval) {
                            clearInterval(PlexyfinConfig.syncPollInterval);
                            PlexyfinConfig.syncPollInterval = null;
                        }

                        var syncStatus = document.getElementById('syncStatus');
                        var syncProgressMessage = document.getElementById('syncProgressMessage');

                        if (syncStatus) {
                            syncStatus.innerText = 'Connection Error';
                            syncStatus.className = 'alert errorMessage';
                        }

                        if (syncProgressMessage) {
                            syncProgressMessage.innerText = 'Error communicating with server. The sync may still be running.';
                        }

                        resetUIAfterSync();
                    }
                });
            }

            // Helper function to update the sync progress UI with a simple message
            function updateSyncProgressUI(status, isDryRun) {
                try {
                    // Get our simple UI elements
                    var syncStatus = document.getElementById('syncStatus');
                    var syncProgressMessage = document.getElementById('syncProgressMessage');

                    if (!syncStatus || !syncProgressMessage) {
                        console.error('Missing sync status UI elements');
                        return false;
                    }

                    // Status message based on sync status
                    var statusMessage = status.message || 'Processing...';

                    // For watch state syncs that track progress
                    if (status.totalItems > 0) {
                        var percentComplete = Math.floor((status.processedItems / status.totalItems) * 100);
                        var remainingText = '';

                        if (status.remainingItems > 0) {
                            remainingText = ' (' + status.remainingItems + ' of ' + status.totalItems + ' items remaining)';
                        }

                        statusMessage += ' - ' + percentComplete + '%' + remainingText;
                    }

                    // Add elapsed time information
                    if (status.elapsedSeconds) {
                        var elapsed = status.elapsedSeconds || 0;
                        var minutes = Math.floor(elapsed / 60);
                        var seconds = Math.floor(elapsed % 60);
                        statusMessage += ' - Time elapsed: ' + minutes + 'm ' + seconds + 's';
                    }

                    // Update the UI
                    syncStatus.innerText = isDryRun ? 'Dry Run in Progress...' : 'Sync in Progress...';
                    syncStatus.className = 'alert successMessage';
                    syncProgressMessage.innerText = statusMessage;

                    return true;
                } catch (e) {
                    console.error('Error updating sync progress UI:', e);
                    return false;
                }
            }

            // Helper function to reset UI after sync completes
            function resetUIAfterSync() {
                var syncButton = document.getElementById('btnSyncNow');
                var dryRunButton = document.getElementById('btnDryRun');

                if (syncButton) syncButton.disabled = false;
                if (dryRunButton) dryRunButton.disabled = false;
            }

            // Helper function to show completion message
            function showCompletionMessage(status, isDryRun) {
                var syncStatus = document.getElementById('syncStatus');
                var syncProgressMessage = document.getElementById('syncProgressMessage');

                if (status.result) {
                    // Set status message
                    if (syncStatus) {
                        syncStatus.innerText = isDryRun ? 'Dry Run Completed' : 'Sync Completed';
                        syncStatus.className = 'alert successMessage';
                    }

                    // Build detailed message
                    var detailedMessage = '';

                    if (status.result.collectionsAdded > 0 || status.result.collectionsUpdated > 0) {
                        detailedMessage += (isDryRun ? 'Would add' : 'Added') + ' ' +
                                  status.result.collectionsAdded + ' collections, ' +
                                  (isDryRun ? 'would update' : 'updated') + ' ' +
                                  status.result.collectionsUpdated + ' collections. ';
                    }
                    
                    if (status.result.itemArtworkUpdated > 0) {
                        detailedMessage += (isDryRun ? 'Would update' : 'Updated') + ' artwork for ' +
                                  status.result.itemArtworkUpdated + ' items. ';
                    }

                    // Update progress message with details
                    if (syncProgressMessage) {
                        syncProgressMessage.innerText = detailedMessage || 'Operation completed successfully.';
                    }

                    // For dry run, show the detailed report
                    if (isDryRun && status.result.details) {
                        var dryRunButton = document.createElement('button');
                        dryRunButton.is = 'emby-button';
                        dryRunButton.type = 'button';
                        dryRunButton.className = 'raised';
                        dryRunButton.style.marginTop = '10px';
                        dryRunButton.innerHTML = '<span>View Detailed Report</span>';
                        dryRunButton.onclick = function() {
                            generateDryRunReport(status.result.details);
                        };

                        if (syncProgressMessage) {
                            syncProgressMessage.appendChild(document.createElement('br'));
                            syncProgressMessage.appendChild(document.createElement('br'));
                            syncProgressMessage.appendChild(dryRunButton);
                        }
                    }
                } else {
                    // Default message if no results
                    if (syncStatus) {
                        syncStatus.innerText = isDryRun ? 'Dry Run Completed' : 'Sync Completed';
                        syncStatus.className = 'alert successMessage';
                    }

                    if (syncProgressMessage) {
                        syncProgressMessage.innerText = 'Operation completed but no detailed results were returned.';
                    }
                }
            }

            function saveConfiguration() {
                Dashboard.showLoadingMsg();

                // Get current configuration
                ApiClient.getPluginConfiguration(PlexyfinConfig.pluginUniqueId).then(function (config) {
                    // Store original scheduled sync settings to detect changes
                    var originalEnableScheduledSync = config.EnableScheduledSync;
                    var originalSyncIntervalHours = config.SyncIntervalHours;
                    
                    // Update with new values from form
                    config.PlexServerUrl = document.querySelector('#PlexServerUrl').value;
                    config.PlexApiToken = document.querySelector('#PlexApiToken').value;
                    config.SyncCollections = document.querySelector('#SyncCollections').checked;
                    // SyncPlaylists setting removed
                    // DeleteBeforeSync setting removed - collections are now always created precisely
                    config.SyncArtwork = document.querySelector('#SyncArtwork').checked;
                    config.SyncItemArtwork = document.querySelector('#SyncItemArtwork').checked;
                    config.EnableScheduledSync = document.querySelector('#EnableScheduledSync').checked;
                    config.EnableDebugMode = document.querySelector('#EnableDebugMode').checked;
                    config.JellyfinBaseUrl = document.querySelector('#JellyfinBaseUrl').value || '';

                    // Parse the sync interval with validation
                    var syncInterval = parseInt(document.querySelector('#SyncIntervalHours').value);
                    if (isNaN(syncInterval) || syncInterval < 1) {
                        syncInterval = 24; // Default to 24 hours if invalid
                    } else if (syncInterval > 168) {
                        syncInterval = 168; // Cap at 168 hours (1 week)
                    }
                    config.SyncIntervalHours = syncInterval;

                    // MaxUrlPatternAttempts setting removed as it's no longer needed

                    // Make sure selected libraries are included
                    config.SelectedLibraries = PlexyfinConfig.selectedLibraryIds;

                    // Check if scheduled sync settings have changed
                    var scheduledSyncChanged = (originalEnableScheduledSync !== config.EnableScheduledSync) || 
                                              (originalSyncIntervalHours !== config.SyncIntervalHours);

                    // Save updated configuration
                    ApiClient.updatePluginConfiguration(PlexyfinConfig.pluginUniqueId, config).then(function (result) {
                        Dashboard.processPluginConfigurationUpdateResult(result);
                        
                        if (scheduledSyncChanged) {
                            showMessage('Settings saved successfully! Please restart Jellyfin for scheduled sync changes to take effect.', false);
                        } else {
                            showMessage('Settings saved successfully!', false);
                        }
                    });
                });
            }

            // Initialize the page
            function initializePage() {
                console.log('Initializing Plexyfin plugin page...');

                // Load configuration from server
                Dashboard.showLoadingMsg();
                ApiClient.getPluginConfiguration(PlexyfinConfig.pluginUniqueId).then(function (config) {
                    console.log('Configuration loaded successfully');

                    // Fill form with saved configuration
                    document.querySelector('#PlexServerUrl').value = config.PlexServerUrl || '';
                    document.querySelector('#PlexApiToken').value = config.PlexApiToken || '';
                    document.querySelector('#SyncCollections').checked = config.SyncCollections;
                    // SyncPlaylists setting removed
                    // DeleteBeforeSync setting removed
                    document.querySelector('#SyncArtwork').checked = config.SyncArtwork;
                    document.querySelector('#SyncItemArtwork').checked = config.SyncItemArtwork || false;
                    document.querySelector('#EnableScheduledSync').checked = config.EnableScheduledSync;
                    document.querySelector('#SyncIntervalHours').value = config.SyncIntervalHours || 24;
                    document.querySelector('#EnableDebugMode').checked = config.EnableDebugMode || false;
                    document.querySelector('#JellyfinBaseUrl').value = config.JellyfinBaseUrl || '';
                    // MaxUrlPatternAttempts setting removed as it's no longer needed

                    // Store selected libraries
                    PlexyfinConfig.selectedLibraryIds = config.SelectedLibraries || [];

                    // If we have Plex credentials, test the connection to get libraries
                    if (config.PlexServerUrl && config.PlexApiToken) {
                        console.log('Plex credentials found, testing connection...');
                        testPlexConnection();
                    }

                    Dashboard.hideLoadingMsg();
                }).catch(function(error) {
                    console.error('Error loading configuration:', error);
                    Dashboard.hideLoadingMsg();
                    showMessage('Error loading plugin configuration. Please refresh the page and try again.', true);
                });
            }


            // Run the page initialization
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializePage);
            } else {
                // DOMContentLoaded already fired
                initializePage();
            }

            function generateDryRunReport(details) {
                // Get current date and timestamp for the report
                var now = new Date();
                var timestamp = now.toISOString().replace('T', ' ').substring(0, 19);

                // Make sure we access properties correctly from the API response
                var addCount = details.collectionsToAdd?.length || 0;
                var updateCount = details.collectionsToUpdate?.length || 0;
                var watchCount = 0;
                var totalChanges = addCount + updateCount;

                // Create HTML parts separately to avoid template string issues

                // Head section with styles
                var head = '<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Plexyfin Dry Run Report - ' + timestamp + '</title>\n    <style>\n        /* Base styles */\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        /* Header styles */\n        .header {\n            background-color: #00a4dc;\n            color: white;\n            padding: 20px;\n            border-radius: 5px;\n            margin-bottom: 20px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        \n        .header h1 {\n            margin: 0;\n            font-size: 24px;\n        }\n        \n        .header p {\n            margin: 5px 0 0 0;\n            opacity: 0.9;\n        }\n        \n        /* Summary section */\n        .summary {\n            background-color: #e9f7fd;\n            border-left: 4px solid #00a4dc;\n            padding: 15px;\n            margin-bottom: 25px;\n            border-radius: 0 5px 5px 0;\n        }\n        \n        /* Section styles */\n        .section {\n            background-color: white;\n            border-radius: 5px;\n            padding: 20px;\n            margin-bottom: 25px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n        }\n        \n        .section h2 {\n            color: #00a4dc;\n            margin-top: 0;\n            border-bottom: 1px solid #eee;\n            padding-bottom: 10px;\n        }\n        \n        /* Collection and item list styles */\n        .item-list {\n            list-style: none;\n            padding: 0;\n            margin: 0;\n        }\n        \n        .item {\n            background-color: #f9f9f9;\n            border-radius: 4px;\n            padding: 15px;\n            margin-bottom: 10px;\n            border-left: 3px solid #ccc;\n        }\n        \n        .item.add {\n            border-left-color: #4caf50;\n        }\n        \n        .item.update {\n            border-left-color: #ff9800;\n        }\n        \n        .item.watch {\n            border-left-color: #9c27b0;\n        }\n        \n        .item-title {\n            font-weight: bold;\n            margin-bottom: 5px;\n        }\n        \n        .item-summary {\n            font-style: italic;\n            margin-bottom: 10px;\n            color: #666;\n        }\n        \n        .item-content {\n            margin-top: 10px;\n        }\n        \n        /* Statistics section */\n        .stats {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n            margin-bottom: 25px;\n        }\n        \n        .stat-box {\n            flex: 1;\n            min-width: 200px;\n            background-color: white;\n            padding: 15px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n            text-align: center;\n        }\n        \n        .stat-number {\n            font-size: 36px;\n            font-weight: bold;\n            color: #00a4dc;\n            margin: 10px 0;\n        }\n        \n        .stat-label {\n            color: #666;\n            font-size: 14px;\n        }\n        \n        /* No changes message */\n        .no-changes {\n            background-color: #f5f5f5;\n            padding: 30px;\n            text-align: center;\n            border-radius: 5px;\n            color: #666;\n            font-style: italic;\n        }\n        \n        /* Footer */\n        .footer {\n            text-align: center;\n            margin-top: 30px;\n            padding-top: 20px;\n            border-top: 1px solid #eee;\n            color: #999;\n            font-size: 12px;\n        }\n        \n        /* Responsive adjustments */\n        @media (max-width: 768px) {\n            .stats {\n                flex-direction: column;\n            }\n            \n            .stat-box {\n                min-width: unset;\n            }\n        }\n    </style>\n</head>';

                // Body section with header and summary
                var body = '<body>\n    <div class="header">\n        <h1>Plexyfin Dry Run Report</h1>\n        <p>Generated on ' + timestamp + '</p>\n    </div>\n    \n    <div class="summary">\n        <p>The following changes would be made if a sync was performed.</p>\n    </div>';

                // Statistics section
                var artworkCount = status.result.itemArtworkUpdated || 0;
                var stats = '\n    <div class="stats">\n        <div class="stat-box">\n            <div class="stat-number">' + (addCount || 0) + '</div>\n            <div class="stat-label">Collections to Add</div>\n        </div>\n        <div class="stat-box">\n            <div class="stat-number">' + (updateCount || 0) + '</div>\n            <div class="stat-label">Collections to Update</div>\n        </div>\n';
                
                if (artworkCount > 0) {
                    stats += '        <div class="stat-box">\n            <div class="stat-number">' + artworkCount + '</div>\n            <div class="stat-label">Items with Artwork Updates</div>\n        </div>\n';
                }
                
                stats += '        <div class="stat-box">\n            <div class="stat-number">' + (totalChanges + artworkCount || 0) + '</div>\n            <div class="stat-label">Total Changes</div>\n        </div>\n    </div>';

                // Build the body content
                var content = "";

                // If there are no changes, show a message
                if (totalChanges === 0 && artworkCount === 0) {
                    content += '\n    <div class="no-changes">\n        <h2>No Changes Would Be Made</h2>\n        <p>Your Jellyfin collections and watch states are already in sync with Plex.</p>\n    </div>';
                } else {
                    // Add Collections to Add section
                    if (details.collectionsToAdd?.length > 0) {
                        content += '\n    <div class="section">\n        <h2>Collections That Would Be Added (' + details.collectionsToAdd.length + ')</h2>\n        <ul class="item-list">';

                        for (var i = 0; i < details.collectionsToAdd.length; i++) {
                            var collection = details.collectionsToAdd[i];
                            var collectionTitle = collection.title || 'Unnamed Collection';

                            content += '\n            <li class="item add">\n                <div class="item-title">' + collectionTitle + '</div>';

                            if (collection.summary) {
                                content += '\n                <div class="item-summary">' + collection.summary + '</div>';
                            }

                            content += '\n                <div class="item-content"><strong>Items:</strong> ';

                            if (collection.items && collection.items.length > 0) {
                                content += collection.items.join(', ');
                            } else {
                                content += 'None';
                            }

                            content += '</div>\n            </li>';
                        }

                        content += '\n        </ul>\n    </div>';
                    }

                    // Add Collections to Update section
                    if (details.collectionsToUpdate?.length > 0) {
                        content += '\n    <div class="section">\n        <h2>Collections That Would Be Updated (' + details.collectionsToUpdate.length + ')</h2>\n        <ul class="item-list">';

                        for (var i = 0; i < details.collectionsToUpdate.length; i++) {
                            var collection = details.collectionsToUpdate[i];
                            var collectionTitle = collection.title || 'Unnamed Collection';

                            content += '\n            <li class="item update">\n                <div class="item-title">' + collectionTitle + '</div>';

                            if (collection.summary) {
                                content += '\n                <div class="item-summary">' + collection.summary + '</div>';
                            }

                            content += '\n                <div class="item-content"><strong>Items:</strong> ';

                            if (collection.items && collection.items.length > 0) {
                                content += collection.items.join(', ');
                            } else {
                                content += 'None';
                            }

                            content += '</div>\n            </li>';
                        }

                        content += '\n        </ul>\n    </div>';
                    }
                    
                    // Item Artwork section
                    if (artworkCount > 0) {
                        content += '\n    <div class="section">\n        <h2>Artwork That Would Be Updated (' + artworkCount + ' items)</h2>';
                        content += '\n        <p>Artwork for ' + artworkCount + ' items would be updated from Plex. This includes poster images and backdrop art.</p>';
                        content += '\n    </div>';
                    }

                    // Watch States section removed
                }

                // Add footer
                var footer = '\n    <div class="footer">\n        <p>Generated by Plexyfin plugin for Jellyfin</p>\n        <p>Click "Sync Now" in the plugin settings to apply these changes</p>\n    </div>\n</body>\n</html>';

                // Combine all sections into a complete HTML document
                var reportHtml = head + body + stats + content + footer;

                // Open a new window/tab with the report
                var reportWindow = window.open('', '_blank');
                reportWindow.document.write(reportHtml);
                reportWindow.document.close();
            }
        </script>
    </div>
</body>
</html>
