<!DOCTYPE html>
<html>
<head>
    <title>Plexyfin</title>
    <style>
        /* Progress bar styling */
        .progress-container {
            width: 100%;
            background-color: #f3f3f3;
            border-radius: 6px;
            margin: 15px 0;
            padding: 15px;
            display: none;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .progress-bar {
            height: 24px;
            background-color: #00a4dc;
            border-radius: 4px;
            text-align: center;
            color: white;
            line-height: 24px;
            font-weight: bold;
            transition: width 0.3s ease;
        }
        .progress-status {
            margin-top: 10px;
            padding: 8px;
            font-size: 15px;
            background-color: #e9f7fd;
            border-left: 4px solid #00a4dc;
            border-radius: 0 4px 4px 0;
        }
        .progress-elapsed {
            margin-top: 10px;
            padding: 8px 12px;
            font-size: 14px;
            color: #555;
            font-weight: 500;
            background-color: #f7f3e9;
            border-left: 4px solid #f9b115;
            border-radius: 0 4px 4px 0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
    </style>
</head>
<body>
    <div id="Plexyfin" data-role="page" class="page type-interior pluginConfigurationPage">
        <div data-role="content">
            <div class="content-primary">
                <div class="verticalSection">
                    <div class="sectionTitleContainer">
                        <h2 class="sectionTitle">Plex Server Configuration</h2>
                    </div>
                    <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                        Configure the connection to your Plex Media Server. This is required for syncing collections and other data.
                    </div>
                </div>
                
                <form class="plexyfinconfigurationForm">
                    <div class="inputContainer">
                        <label for="PlexServerUrl">Plex Server URL:</label>
                        <input id="PlexServerUrl" name="PlexServerUrl" type="text" 
                               placeholder="http://plexserver:32400" required />
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Enter the URL to your Plex Media Server, including port number (e.g., http://192.168.1.100:32400)
                        </div>
                    </div>
                    
                    <div class="inputContainer">
                        <label for="PlexApiToken">Plex API Token:</label>
                        <input id="PlexApiToken" name="PlexApiToken" type="password" required />
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Enter your Plex API Token. You can find this by following the instructions 
                            <a href="https://support.plex.tv/articles/204059436-finding-an-authentication-token-x-plex-token/" 
                              target="_blank">here</a>.
                        </div>
                    </div>
                    
                    <div>
                        <button is="emby-button" type="button" class="raised" id="btnTestConnection">
                            <span>Test Connection</span>
                        </button>
                        <div class="fieldDescription" id="connectionStatus" style="margin-top: 10px;"></div>
                    </div>
                    
                    <div class="verticalSection" id="plexLibrariesSection" style="display: none;">
                        <h3 class="sectionTitle">Plex Libraries</h3>
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Select which Plex libraries to include when syncing collections and playlists.
                            Only selected libraries will be synchronized. By default, all libraries are selected.
                        </div>
                        
                        <div id="libraryList" style="margin-top: 10px;">
                            <!-- Libraries will be populated here dynamically -->
                        </div>
                        
                        <div class="buttonContainer" style="margin-top: 15px;">
                            <button is="emby-button" type="button" class="raised" id="btnSelectAllLibraries">
                                <span>Select All</span>
                            </button>
                            <button is="emby-button" type="button" class="raised" id="btnUnselectAllLibraries" style="margin-left: 10px;">
                                <span>Unselect All</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="verticalSection">
                        <h3 class="sectionTitle">Sync Options</h3>
                        
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="SyncCollections" />
                                <span>Sync Collections from Plex</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, collections from Plex will be synced to Jellyfin.
                        </div>
                        
                        <!-- Playlist sync feature removed -->
                        
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="DeleteBeforeSync" />
                                <span>Delete Existing Collections Before Syncing</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, all existing collections in Jellyfin will be deleted before syncing from Plex.
                            This ensures there are no duplicate or stale collections from previous sync operations.
                            <b>Note:</b> By default, without this enabled, the plugin will update existing collections
                            and create any new ones that don't exist.
                        </div>
                        
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="SyncArtwork" />
                                <span>Sync Collection Artwork</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, collection posters and backdrops will be synced from Plex to Jellyfin.
                        </div>
                        
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="SyncWatchState" />
                                <span>Sync Watch State</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, watched/unwatched status will be synchronized between Plex and Jellyfin.
                            Only items in the selected libraries will be synchronized.
                        </div>
                        
                        <div class="inputContainer" id="watchStateDirectionContainer" style="margin-left: 25px; display: none;">
                            <label for="SyncWatchStateDirection">Watch State Sync Direction:</label>
                            <select id="SyncWatchStateDirection" name="SyncWatchStateDirection">
                                <option value="PlexToJellyfin">Plex to Jellyfin (one-way)</option>
                                <option value="JellyfinToPlex">Jellyfin to Plex (one-way)</option>
                                <option value="Bidirectional">Bidirectional (both ways)</option>
                            </select>
                            <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                                Choose how watch state should be synchronized between the two platforms.
                            </div>
                        </div>
                    </div>
                    
                    <div class="verticalSection">
                        <h3 class="sectionTitle">Scheduled Sync</h3>
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="EnableScheduledSync" />
                                <span>Enable Scheduled Sync</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, collections and playlists will be automatically synced on the schedule below.
                        </div>
                        
                        <div class="inputContainer">
                            <label for="SyncIntervalHours">Sync Interval (Hours):</label>
                            <input id="SyncIntervalHours" name="SyncIntervalHours" type="number" min="1" max="168" step="1" />
                            <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                                How often to sync from Plex (in hours). Minimum 1 hour, maximum 168 hours (1 week).
                            </div>
                        </div>
                    </div>
                    
                    <div class="verticalSection">
                        <h3 class="sectionTitle">Advanced Options</h3>
                        
                        <div class="checkboxContainer">
                            <label>
                                <input type="checkbox" id="EnableDebugMode" />
                                <span>Enable Debug Mode</span>
                            </label>
                        </div>
                        <div class="fieldDescription" style="margin-left: 25px; font-size: 90%; margin-bottom: 15px;">
                            When enabled, debug copies of images will be saved and more verbose logging will occur.
                            This can help with troubleshooting but uses more disk space.
                        </div>
                        
                        <!-- MaxUrlPatternAttempts setting removed as it's no longer needed -->
                    </div>
                    
                    <div class="verticalSection">
                        <h3 class="sectionTitle">Save & Sync</h3>
                        <div class="fieldDescription" style="font-size: 90%; margin-bottom: 15px;">
                            Save your configuration and start a manual sync from Plex to Jellyfin.
                        </div>
                        
                        <div class="buttonContainer">
                            <button is="emby-button" type="button" class="raised button-submit" id="btnSaveConfig">
                                <span>Save Settings</span>
                            </button>
                            
                            <button is="emby-button" type="button" class="raised" id="btnSyncNow" style="margin-left: 10px;">
                                <span>Sync Now</span>
                            </button>
                            
                            <button is="emby-button" type="button" class="raised" id="btnDryRun" style="margin-left: 10px;">
                                <span>Dry Run (Preview Changes)</span>
                            </button>
                        </div>
                        
                        <div class="fieldDescription" style="margin-top: 10px;">
                            "Sync Now" will immediately sync collections and watch states based on your settings.<br>
                            "Dry Run" will show what changes would be made without actually applying them.
                        </div>
                        
                        <!-- Progress tracking UI -->
                        <div class="progress-container" id="syncProgressContainer">
                            <div class="progress-bar" id="syncProgressBar">0%</div>
                            <div class="progress-status" id="syncProgressStatus">Initializing...</div>
                            <div class="progress-elapsed" id="syncProgressElapsed"></div>
                        </div>
                        
                        <div class="padded-top" style="margin-top: 1em;">
                            <div class="alert" id="saveResult"></div>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <script type="text/javascript">
            var PlexyfinConfig = {
                pluginUniqueId: 'b9f0c474-e9a8-4292-ae41-eb3c1542f4cd',
                selectedLibraryIds: [], // Will store the selected library IDs
                activeSyncId: null,    // ID of the current sync operation
                syncPollInterval: null // Interval for polling sync status
            };

            document.querySelector('.plexyfinconfigurationForm')
                .addEventListener('submit', function(e) {
                    e.preventDefault();
                    return false;
                });
                
            document.querySelector('#btnSaveConfig')
                .addEventListener('click', function() {
                    saveConfiguration();
                });
                
            document.querySelector('#btnSyncNow')
                .addEventListener('click', function() {
                    startSync(false);
                });
                
            document.querySelector('#btnDryRun')
                .addEventListener('click', function() {
                    startSync(true);
                });
                
            document.querySelector('#btnTestConnection')
                .addEventListener('click', function() {
                    testPlexConnection();
                });
                
            document.querySelector('#btnSelectAllLibraries')
                .addEventListener('click', function() {
                    selectAllLibraries(true);
                });
                
            document.querySelector('#btnUnselectAllLibraries')
                .addEventListener('click', function() {
                    selectAllLibraries(false);
                });
                
            document.querySelector('#SyncWatchState')
                .addEventListener('change', function() {
                    toggleWatchStateDirection();
                });
                
            function toggleWatchStateDirection() {
                const watchStateEnabled = document.querySelector('#SyncWatchState').checked;
                document.querySelector('#watchStateDirectionContainer').style.display = 
                    watchStateEnabled ? 'block' : 'none';
            }

            function showMessage(message, isError) {
                const saveResultElem = document.querySelector('#saveResult');
                saveResultElem.innerText = message;
                if (isError) {
                    saveResultElem.classList.add('errorMessage');
                    saveResultElem.classList.remove('successMessage');
                } else {
                    saveResultElem.classList.add('successMessage');
                    saveResultElem.classList.remove('errorMessage');
                }
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    saveResultElem.innerText = '';
                    saveResultElem.classList.remove('successMessage', 'errorMessage');
                }, 5000);
            }
            
            function showConnectionMessage(message, isError) {
                const connectionStatusElem = document.querySelector('#connectionStatus');
                connectionStatusElem.innerText = message;
                connectionStatusElem.style.color = isError ? 'red' : 'green';
            }
            
            function testPlexConnection() {
                Dashboard.showLoadingMsg();
                
                const url = document.querySelector('#PlexServerUrl').value;
                const token = document.querySelector('#PlexApiToken').value;
                
                if (!url || !token) {
                    showConnectionMessage("Plex server URL and API token are required", true);
                    Dashboard.hideLoadingMsg();
                    return;
                }
                
                ApiClient.ajax({
                    type: 'GET',
                    url: ApiClient.getUrl('/Plexyfin/test-connection') + 
                         '?url=' + encodeURIComponent(url) + 
                         '&token=' + encodeURIComponent(token),
                    dataType: 'json'
                }).then(function(result) {
                    Dashboard.hideLoadingMsg();
                    
                    if (!result.success) {
                        showConnectionMessage(result.error || "Cannot connect to Plex. Check your URL and API Token.", true);
                        document.querySelector('#plexLibrariesSection').style.display = 'none';
                        return;
                    }
                    
                    // Display the raw libraries data to debug
                    console.log("Libraries data:", JSON.stringify(result.libraries));
                    
                    // Show the libraries section
                    document.querySelector('#plexLibrariesSection').style.display = 'block';
                    
                    showConnectionMessage(result.message || "Successfully connected to Plex Media Server", false);
                    
                    // Populate the libraries
                    populateLibraries(result.libraries);
                    
                }, function(error) {
                    Dashboard.hideLoadingMsg();
                    showConnectionMessage('Error connecting to Plex: ' + error.status + ' ' + error.statusText, true);
                    document.querySelector('#plexLibrariesSection').style.display = 'none';
                });
            }
            
            function populateLibraries(libraries) {
                const libraryListElement = document.querySelector('#libraryList');
                libraryListElement.innerHTML = '';
                
                if (!libraries || libraries.length === 0) {
                    libraryListElement.innerHTML = '<div>No libraries found in your Plex server.</div>';
                    return;
                }
                
                // Debug the raw libraries data
                console.log("Raw libraries array:", libraries);
                
                // Debug each library object in detail
                libraries.forEach(function(lib, index) {
                    console.log(`Library ${index} raw:`, lib);
                    console.log(`Library ${index} JSON:`, JSON.stringify(lib));
                    
                    // Log the property names directly
                    const propNames = Object.keys(lib);
                    console.log(`Library ${index} property names:`, propNames);
                });
                
                // Update the global selected libraries
                PlexyfinConfig.selectedLibraryIds = libraries
                    .filter(lib => lib.isSelected === true || lib.IsSelected === true)
                    .map(lib => lib.id || lib.Id || "");
                
                // Create a checkbox for each library
                libraries.forEach(function(library, index) {
                    // Create a div to hold this library entry
                    const libraryItem = document.createElement('div');
                    libraryItem.className = 'checkboxContainer';
                    libraryItem.style.marginBottom = '5px';
                    
                    // Debug this specific library
                    console.log(`Building UI for library ${index}:`, library);
                    
                    // Get properties with proper casing (handle both cases since JSON serialization can vary)
                    const libraryId = library.id || library.Id || '';
                    const libraryTitle = library.title || library.Title || '';
                    const libraryType = library.type || library.Type || '';
                    const isSelected = library.isSelected === true || library.IsSelected === true;
                    
                    console.log(`Library ${index} parsed values:`, {
                        id: libraryId,
                        title: libraryTitle,
                        type: libraryType,
                        isSelected: isSelected
                    });
                    
                    // Format the library type for display (capitalize first letter)
                    let displayType = '';
                    if (libraryType) {
                        displayType = ' (' + libraryType.charAt(0).toUpperCase() + libraryType.slice(1) + ')';
                    }
                    
                    // Create the elements manually instead of using template literals
                    const label = document.createElement('label');
                    label.title = "Debug: id=" + libraryId + ", title=" + libraryTitle + ", type=" + libraryType;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'libraryCheckbox';
                    checkbox.dataset.libraryId = libraryId;
                    checkbox.checked = isSelected;
                    
                    const span = document.createElement('span');
                    span.textContent = (libraryTitle || 'Unnamed Library') + displayType;
                    
                    // Append the elements
                    label.appendChild(checkbox);
                    label.appendChild(span);
                    libraryItem.appendChild(label);
                    
                    libraryListElement.appendChild(libraryItem);
                });
                
                // Add event listeners to all checkboxes
                document.querySelectorAll('.libraryCheckbox').forEach(function(checkbox) {
                    checkbox.addEventListener('change', function(e) {
                        const libraryId = e.target.dataset.libraryId;
                        
                        if (e.target.checked) {
                            // Add to selected libraries if not already there
                            if (!PlexyfinConfig.selectedLibraryIds.includes(libraryId)) {
                                PlexyfinConfig.selectedLibraryIds.push(libraryId);
                                console.log('Added library: ' + libraryId);
                            }
                        } else {
                            // Remove from selected libraries
                            const index = PlexyfinConfig.selectedLibraryIds.indexOf(libraryId);
                            if (index !== -1) {
                                PlexyfinConfig.selectedLibraryIds.splice(index, 1);
                                console.log('Removed library: ' + libraryId);
                            }
                        }
                        
                        // Update server with new selection
                        updateSelectedLibraries();
                    });
                });
            }
            
            function selectAllLibraries(selectAll) {
                const checkboxes = document.querySelectorAll('.libraryCheckbox');
                
                // Clear the selection array if deselecting all
                if (!selectAll) {
                    PlexyfinConfig.selectedLibraryIds = [];
                }
                
                checkboxes.forEach(function(checkbox) {
                    checkbox.checked = selectAll;
                    
                    const libraryId = checkbox.dataset.libraryId;
                    
                    if (selectAll) {
                        // Add to selected libraries if not already there
                        if (!PlexyfinConfig.selectedLibraryIds.includes(libraryId)) {
                            PlexyfinConfig.selectedLibraryIds.push(libraryId);
                        }
                    }
                });
                
                // Log the current selection
                console.log('Selected libraries (' + (selectAll ? 'all' : 'none') + '): ', 
                    PlexyfinConfig.selectedLibraryIds);
                
                // Update server with new selection
                updateSelectedLibraries();
            }
            
            function updateSelectedLibraries() {
                console.log('Sending selection to server: ', PlexyfinConfig.selectedLibraryIds);
                
                ApiClient.ajax({
                    type: 'POST',
                    url: ApiClient.getUrl('/Plexyfin/UpdateSelectedLibraries'),
                    data: JSON.stringify(PlexyfinConfig.selectedLibraryIds),
                    contentType: 'application/json'
                }).then(function(result) {
                    // Success
                    console.log('Successfully updated selected libraries');
                    showConnectionMessage('Library selection updated successfully', false);
                    
                    // Hide message after 3 seconds
                    setTimeout(function() {
                        document.querySelector('#connectionStatus').innerHTML = '';
                    }, 3000);
                }, function(error) {
                    console.error('Error updating libraries: ', error);
                    showMessage('Error updating selected libraries: ' + error.status + ' ' + error.statusText, true);
                });
            }
            
            function startSync(isDryRun) {
                // Clear any existing sync state
                clearInterval(PlexyfinConfig.syncPollInterval);
                PlexyfinConfig.activeSyncId = null;
                
                // Clear result message
                document.querySelector('#saveResult').innerText = '';
                
                // Show progress bar
                const progressContainer = document.querySelector('#syncProgressContainer');
                const progressBar = document.querySelector('#syncProgressBar');
                const progressStatus = document.querySelector('#syncProgressStatus');
                const progressElapsed = document.querySelector('#syncProgressElapsed');
                
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                progressStatus.textContent = isDryRun ? 'Starting dry run...' : 'Starting sync...';
                progressElapsed.textContent = '';
                
                // Disable buttons
                document.querySelector('#btnSyncNow').disabled = true;
                document.querySelector('#btnDryRun').disabled = true;
                
                // Start the sync operation
                ApiClient.ajax({
                    type: 'POST',
                    url: ApiClient.getUrl('/Plexyfin/' + (isDryRun ? 'DryRunSync' : 'sync')),
                    dataType: 'json'
                }).then(function(result) {
                    if (!result.success) {
                        showMessage(result.error || 'Failed to start sync operation', true);
                        progressContainer.style.display = 'none';
                        document.querySelector('#btnSyncNow').disabled = false;
                        document.querySelector('#btnDryRun').disabled = false;
                        return;
                    }
                    
                    console.log('Sync operation started with ID:', result.syncId);
                    PlexyfinConfig.activeSyncId = result.syncId;
                    
                    // Start polling for status
                    PlexyfinConfig.syncPollInterval = setInterval(function() {
                        pollSyncStatus(isDryRun);
                    }, 1000); // Poll every second
                    
                }, function(error) {
                    showMessage('Error starting ' + (isDryRun ? 'dry run' : 'sync') + ': ' + error.status + ' ' + error.statusText, true);
                    progressContainer.style.display = 'none';
                    document.querySelector('#btnSyncNow').disabled = false;
                    document.querySelector('#btnDryRun').disabled = false;
                });
            }
            
            function pollSyncStatus(isDryRun) {
                if (!PlexyfinConfig.activeSyncId) return;
                
                ApiClient.ajax({
                    type: 'GET',
                    url: ApiClient.getUrl('/Plexyfin/sync-status/' + PlexyfinConfig.activeSyncId),
                    dataType: 'json'
                }).then(function(status) {
                    if (!status.success) {
                        clearInterval(PlexyfinConfig.syncPollInterval);
                        showMessage('Error: ' + status.message, true);
                        document.querySelector('#syncProgressContainer').style.display = 'none';
                        document.querySelector('#btnSyncNow').disabled = false;
                        document.querySelector('#btnDryRun').disabled = false;
                        return;
                    }
                    
                    // Update progress
                    const progressBar = document.querySelector('#syncProgressBar');
                    const progressStatus = document.querySelector('#syncProgressStatus');
                    const progressElapsed = document.querySelector('#syncProgressElapsed');
                    
                    // For collection syncs, just show the message
                    if (status.totalItems === 0 || status.message.includes("collections")) {
                        // Hide progress percentage for collection syncs (they're usually quick)
                        progressBar.style.width = '100%';
                        progressBar.textContent = 'In progress...';
                    } else {
                        // For watch state syncs, show detailed progress based on items remaining
                        let percentComplete = 0;
                        
                        if (status.totalItems > 0) {
                            percentComplete = Math.floor((status.processedItems / status.totalItems) * 100);
                        } else {
                            percentComplete = status.progress;
                        }
                        
                        progressBar.style.width = percentComplete + '%';
                        progressBar.textContent = percentComplete + '%';
                    }
                    
                    // Set status message
                    progressStatus.textContent = status.message;
                    
                    // Format elapsed time
                    const elapsed = status.elapsedSeconds;
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = Math.floor(elapsed % 60);
                    
                    // Add remaining items info if available
                    let timeText = "Time elapsed: " + minutes + " min " + seconds + " sec";
                    
                    if (status.totalItems > 0 && status.remainingItems > 0) {
                        timeText += " | " + status.remainingItems + " of " + status.totalItems + " items remaining";
                    }
                    
                    progressElapsed.textContent = timeText;
                    
                    // Check if sync is complete
                    if (status.isComplete) {
                        clearInterval(PlexyfinConfig.syncPollInterval);
                        
                        // Re-enable buttons
                        document.querySelector('#btnSyncNow').disabled = false;
                        document.querySelector('#btnDryRun').disabled = false;
                        
                        // Hide progress bar after 5 seconds
                        setTimeout(() => {
                            document.querySelector('#syncProgressContainer').style.display = 'none';
                        }, 5000);
                        
                        // Show completion message
                        if (status.result) {
                            let message = isDryRun ? 'Dry run completed successfully. ' : 'Sync completed successfully. ';
                            
                            if (status.result.collectionsAdded > 0 || status.result.collectionsUpdated > 0) {
                                message += `${isDryRun ? 'Would add' : 'Added'} ${status.result.collectionsAdded} collections, ${isDryRun ? 'would update' : 'updated'} ${status.result.collectionsUpdated} collections. `;
                            }
                            
                            if (status.result.details && status.result.details.watchStatesChanged) {
                                const watchCount = status.result.details.watchStatesChanged.length;
                                message += `${isDryRun ? 'Would change' : 'Changed'} ${watchCount} watch states.`;
                            }
                            
                            showMessage(message, false);
                            
                            // For dry run, show the detailed report
                            if (isDryRun && status.result.details) {
                                generateDryRunReport(status.result.details);
                            }
                        } else {
                            showMessage('Operation completed but no results were returned', false);
                        }
                    }
                }, function(error) {
                    console.error('Error polling sync status:', error);
                    // Don't stop polling on temporary errors
                });
            }
            
            function saveConfiguration() {
                Dashboard.showLoadingMsg();
                
                // Get current configuration
                ApiClient.getPluginConfiguration(PlexyfinConfig.pluginUniqueId).then(function (config) {
                    // Update with new values from form
                    config.PlexServerUrl = document.querySelector('#PlexServerUrl').value;
                    config.PlexApiToken = document.querySelector('#PlexApiToken').value;
                    config.SyncCollections = document.querySelector('#SyncCollections').checked;
                    // SyncPlaylists setting removed
                    config.DeleteBeforeSync = document.querySelector('#DeleteBeforeSync').checked;
                    config.SyncArtwork = document.querySelector('#SyncArtwork').checked;
                    config.EnableScheduledSync = document.querySelector('#EnableScheduledSync').checked;
                    config.EnableDebugMode = document.querySelector('#EnableDebugMode').checked;
                    config.SyncWatchState = document.querySelector('#SyncWatchState').checked;
                    config.SyncWatchStateDirection = document.querySelector('#SyncWatchStateDirection').value;
                    
                    // Parse the sync interval with validation
                    var syncInterval = parseInt(document.querySelector('#SyncIntervalHours').value);
                    if (isNaN(syncInterval) || syncInterval < 1) {
                        syncInterval = 24; // Default to 24 hours if invalid
                    } else if (syncInterval > 168) {
                        syncInterval = 168; // Cap at 168 hours (1 week)
                    }
                    config.SyncIntervalHours = syncInterval;
                    
                    // MaxUrlPatternAttempts setting removed as it's no longer needed
                    
                    // Make sure selected libraries are included
                    config.SelectedLibraries = PlexyfinConfig.selectedLibraryIds;
                    
                    // Save updated configuration
                    ApiClient.updatePluginConfiguration(PlexyfinConfig.pluginUniqueId, config).then(function (result) {
                        Dashboard.processPluginConfigurationUpdateResult(result);
                        showMessage('Settings saved successfully!', false);
                    });
                });
            }

            // Load configuration from server
            Dashboard.showLoadingMsg();
            ApiClient.getPluginConfiguration(PlexyfinConfig.pluginUniqueId).then(function (config) {
                // Fill form with saved configuration
                document.querySelector('#PlexServerUrl').value = config.PlexServerUrl || '';
                document.querySelector('#PlexApiToken').value = config.PlexApiToken || '';
                document.querySelector('#SyncCollections').checked = config.SyncCollections;
                // SyncPlaylists setting removed
                document.querySelector('#DeleteBeforeSync').checked = config.DeleteBeforeSync;
                document.querySelector('#SyncArtwork').checked = config.SyncArtwork;
                document.querySelector('#EnableScheduledSync').checked = config.EnableScheduledSync;
                document.querySelector('#SyncIntervalHours').value = config.SyncIntervalHours || 24;
                document.querySelector('#EnableDebugMode').checked = config.EnableDebugMode || false;
                // MaxUrlPatternAttempts setting removed as it's no longer needed
                document.querySelector('#SyncWatchState').checked = config.SyncWatchState || false;
                document.querySelector('#SyncWatchStateDirection').value = config.SyncWatchStateDirection || 'PlexToJellyfin';
                
                // Show/hide watch state direction based on checkbox
                toggleWatchStateDirection();
                
                // Store selected libraries
                PlexyfinConfig.selectedLibraryIds = config.SelectedLibraries || [];
                
                // If we have Plex credentials, test the connection to get libraries
                if (config.PlexServerUrl && config.PlexApiToken) {
                    testPlexConnection();
                }
                
                Dashboard.hideLoadingMsg();
            });
            
            function generateDryRunReport(details) {
                // Get current date and timestamp for the report
                var now = new Date();
                var timestamp = now.toISOString().replace('T', ' ').substring(0, 19);
                
                // Make sure we access properties correctly from the API response
                var addCount = details.collectionsToAdd?.length || 0;
                var updateCount = details.collectionsToUpdate?.length || 0;
                var watchCount = details.watchStatesChanged?.length || 0;
                var totalChanges = addCount + updateCount + watchCount;
                
                // Create HTML parts separately to avoid template string issues
                
                // Head section with styles
                var head = '<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Plexyfin Dry Run Report - ' + timestamp + '</title>\n    <style>\n        /* Base styles */\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            max-width: 1200px;\n            margin: 0 auto;\n            padding: 20px;\n            background-color: #f5f5f5;\n        }\n        \n        /* Header styles */\n        .header {\n            background-color: #00a4dc;\n            color: white;\n            padding: 20px;\n            border-radius: 5px;\n            margin-bottom: 20px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }\n        \n        .header h1 {\n            margin: 0;\n            font-size: 24px;\n        }\n        \n        .header p {\n            margin: 5px 0 0 0;\n            opacity: 0.9;\n        }\n        \n        /* Summary section */\n        .summary {\n            background-color: #e9f7fd;\n            border-left: 4px solid #00a4dc;\n            padding: 15px;\n            margin-bottom: 25px;\n            border-radius: 0 5px 5px 0;\n        }\n        \n        /* Section styles */\n        .section {\n            background-color: white;\n            border-radius: 5px;\n            padding: 20px;\n            margin-bottom: 25px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n        }\n        \n        .section h2 {\n            color: #00a4dc;\n            margin-top: 0;\n            border-bottom: 1px solid #eee;\n            padding-bottom: 10px;\n        }\n        \n        /* Collection and item list styles */\n        .item-list {\n            list-style: none;\n            padding: 0;\n            margin: 0;\n        }\n        \n        .item {\n            background-color: #f9f9f9;\n            border-radius: 4px;\n            padding: 15px;\n            margin-bottom: 10px;\n            border-left: 3px solid #ccc;\n        }\n        \n        .item.add {\n            border-left-color: #4caf50;\n        }\n        \n        .item.update {\n            border-left-color: #ff9800;\n        }\n        \n        .item.watch {\n            border-left-color: #9c27b0;\n        }\n        \n        .item-title {\n            font-weight: bold;\n            margin-bottom: 5px;\n        }\n        \n        .item-summary {\n            font-style: italic;\n            margin-bottom: 10px;\n            color: #666;\n        }\n        \n        .item-content {\n            margin-top: 10px;\n        }\n        \n        /* Statistics section */\n        .stats {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 20px;\n            margin-bottom: 25px;\n        }\n        \n        .stat-box {\n            flex: 1;\n            min-width: 200px;\n            background-color: white;\n            padding: 15px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n            text-align: center;\n        }\n        \n        .stat-number {\n            font-size: 36px;\n            font-weight: bold;\n            color: #00a4dc;\n            margin: 10px 0;\n        }\n        \n        .stat-label {\n            color: #666;\n            font-size: 14px;\n        }\n        \n        /* No changes message */\n        .no-changes {\n            background-color: #f5f5f5;\n            padding: 30px;\n            text-align: center;\n            border-radius: 5px;\n            color: #666;\n            font-style: italic;\n        }\n        \n        /* Footer */\n        .footer {\n            text-align: center;\n            margin-top: 30px;\n            padding-top: 20px;\n            border-top: 1px solid #eee;\n            color: #999;\n            font-size: 12px;\n        }\n        \n        /* Responsive adjustments */\n        @media (max-width: 768px) {\n            .stats {\n                flex-direction: column;\n            }\n            \n            .stat-box {\n                min-width: unset;\n            }\n        }\n    </style>\n</head>';
                
                // Body section with header and summary
                var body = '<body>\n    <div class="header">\n        <h1>Plexyfin Dry Run Report</h1>\n        <p>Generated on ' + timestamp + '</p>\n    </div>\n    \n    <div class="summary">\n        <p>The following changes would be made if a sync was performed.</p>\n    </div>';
                
                // Statistics section
                var stats = '\n    <div class="stats">\n        <div class="stat-box">\n            <div class="stat-number">' + (addCount || 0) + '</div>\n            <div class="stat-label">Collections to Add</div>\n        </div>\n        <div class="stat-box">\n            <div class="stat-number">' + (updateCount || 0) + '</div>\n            <div class="stat-label">Collections to Update</div>\n        </div>\n        <div class="stat-box">\n            <div class="stat-number">' + (watchCount || 0) + '</div>\n            <div class="stat-label">Watch States to Change</div>\n        </div>\n        <div class="stat-box">\n            <div class="stat-number">' + (totalChanges || 0) + '</div>\n            <div class="stat-label">Total Changes</div>\n        </div>\n    </div>';
                
                // Build the body content
                var content = "";
                
                // If there are no changes, show a message
                if (totalChanges === 0) {
                    content += '\n    <div class="no-changes">\n        <h2>No Changes Would Be Made</h2>\n        <p>Your Jellyfin collections and watch states are already in sync with Plex.</p>\n    </div>';
                } else {
                    // Add Collections to Add section
                    if (details.collectionsToAdd?.length > 0) {
                        content += '\n    <div class="section">\n        <h2>Collections That Would Be Added (' + details.collectionsToAdd.length + ')</h2>\n        <ul class="item-list">';
                        
                        for (var i = 0; i < details.collectionsToAdd.length; i++) {
                            var collection = details.collectionsToAdd[i];
                            var collectionTitle = collection.title || 'Unnamed Collection';
                            
                            content += '\n            <li class="item add">\n                <div class="item-title">' + collectionTitle + '</div>';
                            
                            if (collection.summary) {
                                content += '\n                <div class="item-summary">' + collection.summary + '</div>';
                            }
                            
                            content += '\n                <div class="item-content"><strong>Items:</strong> ';
                            
                            if (collection.items && collection.items.length > 0) {
                                content += collection.items.join(', ');
                            } else {
                                content += 'None';
                            }
                            
                            content += '</div>\n            </li>';
                        }
                        
                        content += '\n        </ul>\n    </div>';
                    }
                    
                    // Add Collections to Update section
                    if (details.collectionsToUpdate?.length > 0) {
                        content += '\n    <div class="section">\n        <h2>Collections That Would Be Updated (' + details.collectionsToUpdate.length + ')</h2>\n        <ul class="item-list">';
                        
                        for (var i = 0; i < details.collectionsToUpdate.length; i++) {
                            var collection = details.collectionsToUpdate[i];
                            var collectionTitle = collection.title || 'Unnamed Collection';
                            
                            content += '\n            <li class="item update">\n                <div class="item-title">' + collectionTitle + '</div>';
                            
                            if (collection.summary) {
                                content += '\n                <div class="item-summary">' + collection.summary + '</div>';
                            }
                            
                            content += '\n                <div class="item-content"><strong>Items:</strong> ';
                            
                            if (collection.items && collection.items.length > 0) {
                                content += collection.items.join(', ');
                            } else {
                                content += 'None';
                            }
                            
                            content += '</div>\n            </li>';
                        }
                        
                        content += '\n        </ul>\n    </div>';
                    }
                    
                    // Add Watch States to Change section
                    if (details.watchStatesChanged?.length > 0) {
                        content += '\n    <div class="section">\n        <h2>Watch States That Would Be Changed (' + details.watchStatesChanged.length + ')</h2>\n        <ul class="item-list">';
                        
                        for (var i = 0; i < details.watchStatesChanged.length; i++) {
                            var change = details.watchStatesChanged[i];
                            // Use nullish coalescing to default to placeholder text if properties are missing
                            var itemTitle = change.title || 'Unnamed Item';
                            var currentState = change.currentState || 'Unknown';
                            var newState = change.newState || 'Unknown';
                            
                            content += '\n            <li class="item watch">\n                <div class="item-title">' + itemTitle + '</div>\n                <div class="item-content">\n                    <strong>Current:</strong> ' + currentState + '<br>\n                    <strong>Change:</strong> ' + newState + '\n                </div>\n            </li>';
                        }
                        
                        content += '\n        </ul>\n    </div>';
                    }
                }
                
                // Add footer
                var footer = '\n    <div class="footer">\n        <p>Generated by Plexyfin plugin for Jellyfin</p>\n        <p>Click "Sync Now" in the plugin settings to apply these changes</p>\n    </div>\n</body>\n</html>';
                
                // Combine all sections into a complete HTML document
                var reportHtml = head + body + stats + content + footer;
                
                // Open a new window/tab with the report
                var reportWindow = window.open('', '_blank');
                reportWindow.document.write(reportHtml);
                reportWindow.document.close();
            }
        </script>
    </div>
</body>
</html>